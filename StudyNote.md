# 学习笔记
1、JVM虚拟机组成：运行时数据区（内存模型）、类装载子系统、字节码执行引擎
2、JVM内存模型，即Java运行时的内存结构，包括程序计数器、虚拟机栈、堆、方法区、运行时常量池、本地方法栈
    2.1、堆：存储Java运行时产生的对象（包括数组），为所有Java线程所共享
    2.2、栈：包括本地方法栈（Native Method Stacks）和虚拟机栈，方法栈由JVM根据线程为单位进行分配，即方法栈由线程私有，特性如下
        Java方法栈由栈帧组成，栈帧由局部变量表、操作数栈、动态链接、方法出口组成
            2.2.1、局部变量表(Local Variables)：
            2.2.2、操作数栈(Operand Stacks)
            2.2.3、动态链接(Dynamic Linking)
            2.2.4、方法出口：
                2.2.4.1、Normal Method Invocation Completion（正常返回），方法正常返回场景当前栈帧用于恢复调用程序的状态，
                包括其局部变量表和操作数栈，调用程序的程序计数器适当地增加，以跳过方法调用指令。栈帧中被调用方法继续正常执行，
                返回值(如果有的话)被压入栈帧的操作数栈中。
                2.2.4.2、Abrupt Method Invocation Completion（异常返回），方法异常返回场景不会有返回值
            方法返回时可能需要在栈帧中保存一些信息,用来帮助恢复它的上层主调方法的执行状态。一般来说, 方法正常退出时,主调方法的PC计数器
            的值就可以作为返回地址, 栈帧中很可能会保存这个计数器值。而方法异常退出时, 返回地址是要通过异常处理器表来确定的,栈帧中就一般
            不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈, 因此退出时可能执行的操作有:恢复上层方法的局部变量表和操作数栈,
            把返回值(如果有的话)压入调用者栈帧的操作数栈中,调整PC计数器的值以指向方法调用指令后面的一条指令等。
    2.3、程序计数器：全称为Program Counter Register，保存线程执行位置，即程序计数器也是线程私有的，具体特性如下：
        1、它是物理寄存器的抽象实现
        2、保存当前正在执行的指令地址，如果当前线程正在执行Native方法，程序计数器为undefined状态
        3、它是程序控制流的指示器、循环、if else、异常处理、线程恢复等都依赖它来完成
        4、解释器工作时就是通过它来获取下一条需要执行的字节码指令（第2条）
        5、它是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域
    2.4、方法区：保存Java运行时长期不变化的一些信息，包括：常量池、方法信息、类信息，方法区在Java1.7（包括）之前叫方法区，1.7之后叫元空间
    2.5、运行时常量池：运行时常量池是类文件中常量池表的按类或按接口的运行时表示形式，包含几种类型的常量，范围从编译时已知的数值字面量到
    必须在运行时解析的方法和字段参数。运行时常量池的功能类似于传统编程语言的符号表，尽管它包含的数据范围比典型的符号表更大。
    每个运行时常量池由Java虚拟机的方法区分配。类或接口的运行时常量池是在Java虚拟机创建类或接口时构造的。以下异常条件与类或接口的
    运行时常量池的构造相关：
        在创建类或接口时，如果运行时常量池的构造需要比Java虚拟机的方法区可用的内存更多的内存，Java虚拟机将抛出OutOfMemoryError。

clinit：在类的Initializing(初始化)阶段被jvm调用