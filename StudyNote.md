# 学习笔记
1、JVM虚拟机组成：运行时数据区（内存模型）、类装载子系统、字节码执行引擎
2、JVM内存模型，即Java运行时的内存结构，包括堆、栈、程序计数器、方法区、本地栈
    2.1、堆：存储Java运行时产生的对象（包括数组），为所有Java线程所共享
    2.2、栈：包括本地方法栈（Native Stack）和Java方法栈，方法栈由JVM根据线程为单位进行分配，即方法栈由线程私有，特性如下
        Java方法栈由栈帧组成，栈帧由局部变量表、操作数栈、动态链接、方法出口组成
            2.2.1、局部变量表(Local Variables)：
            2.2.2、操作数栈(Operand Stacks)
            2.2.3、动态链接(Dynamic Linking)
            2.2.4、方法出口：
                2.2.4.1、Normal Method Invocation Completion（正常返回），方法正常返回场景当前栈帧用于恢复调用程序的状态，
                包括其局部变量表和操作数栈，调用程序的程序计数器适当地增加，以跳过方法调用指令。栈帧中被调用方法继续正常执行，
                返回值(如果有的话)被压入栈帧的操作数栈中。
                2.2.4.2、Abrupt Method Invocation Completion（异常返回），方法异常返回场景不会有返回值
            方法返回时可能需要在栈帧中保存一些信息,用来帮助恢复它的上层主调方法的执行状态。一般来说, 方法正常退出时,主调方法的PC计数器
            的值就可以作为返回地址, 栈帧中很可能会保存这个计数器值。而方法异常退出时, 返回地址是要通过异常处理器表来确定的,栈帧中就一般
            不会保存这部分信息。方法退出的过程实际上等同于把当前栈帧出栈, 因此退出时可能执行的操作有:恢复上层方法的局部变量表和操作数栈,
            把返回值(如果有的话)压入调用者栈帧的操作数栈中,调整PC计数器的值以指向方法调用指令后面的一条指令等。
    2.3、程序计数器：全称为Program Counter Register，保存线程执行位置，即程序计数器也是线程私有的，具体特性如下：
        1、它是物理寄存器的抽象实现
        2、保存当前正在执行的指令地址，如果当前线程正在执行Native方法，程序计数器为undefined状态
        3、它是程序控制流的指示器、循环、if else、异常处理、线程恢复等都依赖它来完成
        4、解释器工作时就是通过它来获取下一条需要执行的字节码指令（第2条）
        5、它是唯一一个在JVM规范中没有规定任何OutOfMemoryError情况的区域
    2.4、方法区：保存Java运行时长期不变化的一些信息，包括：常量池、方法信息、类信息，方法区在Java1.7（包括）之前叫方法区，1.7之后叫元空间
